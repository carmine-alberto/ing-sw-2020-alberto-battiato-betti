package it.polimi.ingsw.model;

import it.polimi.ingsw.controller.events.BoardUpdate;
import it.polimi.ingsw.model.exceptions.MaxHeightReachedException;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static it.polimi.ingsw.utility.GameSettings.*;

public class FieldCell implements Serializable {
    private transient Game currentGame;
    private GameWorker occupyingWorker;
    private Integer posX, posY, height;
    private Boolean hasDome;

    public FieldCell(Game currentGame, Integer posX, Integer posY) {
        this.occupyingWorker = null;
        this.posX = posX;
        this.posY = posY;
        this.height = 0;
        this.hasDome = false;
        this.currentGame = currentGame;
    }

    public Integer getPosX(){
        return this.posX;
    }

    public Integer getPosY(){
        return this.posY;
    }

    public void setOccupyingWorker(GameWorker worker){
        this.occupyingWorker = worker;
        if (worker != null && !worker.getCell().equals(this))
            worker.setPosition(this);
        currentGame.notifyObservers(new BoardUpdate(currentGame.getField()));
    }

    public Integer getHeight() {
        return height;
    }

    /**
     * Increments the fieldCell height if possible (eg. it has reached its MAX_HEIGHT) and notifies the observers
     */
    public void incrementHeight() {
        try {
            if (height >= MAX_HEIGHT_WITHOUT_DOME)
                throw new MaxHeightReachedException("Invalid move: max height reached");
            height++;
            currentGame.notifyObservers(new BoardUpdate(currentGame.getField()));
        } catch (MaxHeightReachedException e) {
        }
    }

    /**
     * Places a dome in the selected fieldCell and notifies the observers.
     */
    public void placeDome() {
        hasDome = true;
        currentGame.notifyObservers(new BoardUpdate(currentGame.getField()));
    }

    /**
     * Checks whether the fieldCell is on the perimeter of the board or not
     *
     * @return true if it's on the board perimeter
     */
    public Boolean isOnPerimeter() {
        return posX.equals(LOWER_BOUND) || posX.equals(FIELD_SIZE - OFFSET) || posY.equals(LOWER_BOUND) || posY.equals(FIELD_SIZE - OFFSET);
    }

    /**
     * Checks wheter a cell is free.
     * A cell is considered to be free if it has no workers and dome on it
     *
     * @return true if the cell is free, false otherwise
     */
    public Boolean isFree() { return this.occupyingWorker == null && !this.hasDome; }

    /**
     * Checks wheter a cell is complete.
     * A cell is considered to be complete if it has reached its maximum height and it has got a dome
     *
     * @return true if the cell is complete, false otherwise
     */
    public Boolean isComplete() {
        return this.hasDome && this.getHeight() == MAX_HEIGHT_WITHOUT_DOME;
    }

    public Boolean getHasDome() {
        return this.hasDome;
    }

    public GameWorker getWorker() {
        return this.occupyingWorker;
    }

    /**
     * Returns a list of adjacentCells.
     * The adjacentCells are the cells surrounding the selected one
     *
     * @return the list of the cell's adjacent cells
     */
    public List<FieldCell> getAdjacentCells() {
        List<FieldCell> adjacentCells = new ArrayList<>();

        Integer i = Math.max(this.getPosX() - 1, 0);
        Integer k = Math.max(this.getPosY() - 1, 0);

        for (;  i <= this.getPosX() + 1 &&  i < FIELD_SIZE ; i++)
            for (Integer j = k; j <= this.getPosY() + 1 && j < FIELD_SIZE; j++)
                adjacentCells.add(this.currentGame.getCell(i, j));

        adjacentCells.remove(this);

        return adjacentCells;
    }

    /**
     * Checks the equality between two cells.
     * Two cells are equal if they have the same x_coordinate and y_coordinate
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;

        if (o == null || getClass() != o.getClass()) return false;

        FieldCell fieldCell = (FieldCell) o;
        return posX.equals(fieldCell.posX) &&
                posY.equals(fieldCell.posY);
    }

    /**
     * Generated by IntelliJ for free, we'll take it
     * @return the cell hash
     */
    @Override
    public int hashCode() {
        return Objects.hash(posX, posY);
    }


}
